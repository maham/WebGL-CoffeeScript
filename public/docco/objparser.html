<!DOCTYPE html>

<html>
<head>
  <title>ObjParser</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="app.html">
                app.litcoffee
              </a>
            
              
              <a class="source" href="camera.html">
                camera.litcoffee
              </a>
            
              
              <a class="source" href="gl.html">
                gl.litcoffee
              </a>
            
              
              <a class="source" href="glmath.html">
                glmath.litcoffee
              </a>
            
              
              <a class="source" href="loader.html">
                loader.litcoffee
              </a>
            
              
              <a class="source" href="mesh.html">
                mesh.litcoffee
              </a>
            
              
              <a class="source" href="metronome.html">
                metronome.litcoffee
              </a>
            
              
              <a class="source" href="microevent.html">
                microevent.litcoffee
              </a>
            
              
              <a class="source" href="objparser.html">
                objparser.litcoffee
              </a>
            
              
              <a class="source" href="time.html">
                time.litcoffee
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="objparser">ObjParser</h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h2 id="objparser">ObjParser</h2>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>The ObjParser takes a string and parses it as a WaveFront .obj-file. It will create a list of vertices, a list of
normals, a list of texels and a list of faces. Those can then be used to create a mesh for WebGL.</p>
<p><em><strong>WARNING</strong> Only a subset of the specification is supported at the moment and there is no proper handling of
unsupported lines.</em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjParser</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h2 id="constructor">constructor</h2>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>The constructor sets up a few storages for the parsed data. <code>parsed</code> is an array of arrays. The arrays will contain the
vertices, the texels and the normals. <code>out</code> is an array of arrays. The arrays will contain the processed vertices,
texels and normals. <code>indices</code> is an array containing the indices for the index list sent to WebGL. Currently we don’t
try to reuse any vertices so the indices will each point to its own vertex.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-attribute">constructor</span>:<span class="hljs-function"> -&gt;</span>
		<span class="hljs-property">@parsed</span>			= [[],[],[]]
		<span class="hljs-property">@out</span>			= [[],[],[]]
		<span class="hljs-property">@indices</span>		= []</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h2 id="parse">parse</h2>

            </div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>The parse method takes the contents of a .obj file as its only in parameter. The parsing is as simple as splitting the
file on every linebreak and then parse the lines one by one. If the line is empty or begins with a ‘#’ we skip that
line. After trimming the whitespace from the beginning and the end of the line it’s split on every whitespace. The
first token can then be used as the method name to call because of how JavaScript objects works. The remainder of the
array is then passed in as the methods arguments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-attribute">parse</span>: <span class="hljs-function"><span class="hljs-params">( objData )</span> -&gt;</span>
		<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> objData.split <span class="hljs-string">'\n'</span>
			<span class="hljs-keyword">continue</span> <span class="hljs-keyword">if</span> ( line.charAt <span class="hljs-number">0</span> ) == <span class="hljs-string">'#'</span> <span class="hljs-keyword">or</span> line.length &lt; <span class="hljs-number">1</span>
			tokens = line.trim().split <span class="hljs-regexp">/\s+/</span>

			@[tokens[<span class="hljs-number">0</span>]].apply @, tokens[<span class="hljs-number">1.</span>.] <span class="hljs-keyword">if</span> @[tokens[<span class="hljs-number">0</span>]]
		<span class="hljs-keyword">return</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h2 id="v-">v <!----></h2>

            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>A vertex is created from three components, <code>x, y, z</code>. The .obj specification allows for a fourth <code>w</code> component which is
ignored here. The arguments are parsed as floats, packed into an array and pushed into the first <code>parsed</code> array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-attribute">v</span>: <span class="hljs-function"><span class="hljs-params">( x, y, z )</span> -&gt;</span>
		<span class="hljs-property">@parsed</span>[<span class="hljs-number">0</span>].push	[
			parseFloat x
			parseFloat y
			parseFloat z
		]
		<span class="hljs-keyword">return</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h2 id="vn-nbsp-">vn &nbsp;</h2>

            </div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>A normal is created from three components, <code>i, j, k</code>. The arguments are parsed as floats, packed into an array and
pushed into the second <code>parsed</code> array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-attribute">vn</span>: <span class="hljs-function"><span class="hljs-params">( i, j, k )</span> -&gt;</span>
		<span class="hljs-property">@parsed</span>[<span class="hljs-number">1</span>].push [
			parseFloat i
			parseFloat j
			parseFloat k
		]
		<span class="hljs-keyword">return</span></pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h2 id="vt-nbsp-">vt &nbsp;</h2>

            </div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>A texel, texture coordinate, is created from two components, <code>u, v</code>. The .obj specification allows for a third <code>w</code>
component which is ignored here. The arguments are parsed as floats, packed into an array and pushed into the third
<code>parsed</code> array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-attribute">vt</span>: <span class="hljs-function"><span class="hljs-params">( u, v )</span> -&gt;</span>
		<span class="hljs-property">@parsed</span>[<span class="hljs-number">2</span>].push [
			parseFloat u
			parseFloat v
		]
		<span class="hljs-keyword">return</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h2 id="f-nbsp-">f &nbsp;</h2>

            </div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p><em>To render a mesh with OpenGL we usually use a list of vertices and indices. Each vertex as it is sent to the
shader is usually a combination of the position, the normal and the texel. Ex: <code>[X, Y, Z, Nx, Ny, Nz, Tu, Tv]</code>. This is
a vertex of size 8 (eight components in total). When we look at a .obj file it can be very well optimized and a lot of
vertices, texels, normals etc. might be shared between different faces etc. The problem is that with the vertices
packed as shown above each vertex must have all information that is needed for that vertex so we have to combine the
different aspects of the vertex some way. The way we do it here is by letting the f(aces) tell us what parts to combine
into each vertex. If we encounter an f row we will receive an array of indices that in their turn gives the indices of
the v(ertex), the v(ertex)n(ormal) and the v(ertex)t(exel). If we just take those and combine into an array we should
be fine.</em></p>
<p><strong>TODO: Currently we skip all components except the vertex index.</strong></p>
<hr>

            </div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>A face is created from an array of indices. We use a splat <code>...</code> to merge all incoming indices into a single array. To
parse the faces we iterate through all indices. Each index is then split on <code>/</code> to get the indices for the v(ertex),
the v(ertex)t(exel) and the v(ertex)n(ormal). We then continue to loop through the components of the index. The
component is parsed as an int and indicates which v(ertex), v(ertex)t(exel) or v(ertex)n(ormal) that the face point
should use. An index is either absolute and starts with 1 as the first defined v/vn/vt or relative where -1 is the last
defined v/vn/vt. Now we push the indicated v/vt or vn to the <code>out</code> array. We use the push-&gt;apply method to unpack the
vertex data. The <code>out</code> array needs to be a flat array to play well with the WebGL calls. At the moment we just create a
new vertex for every vertex and thus the index will always point to the last vertex. If we add code to reuse vertices
then this will have to be changed to indicate the index of the ‘reused’ vertex if one is found.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-attribute">f</span>: <span class="hljs-function"><span class="hljs-params">( indices... )</span> -&gt;</span>
		<span class="hljs-keyword">for</span> currentIndex <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>..indices.length]
			components = indices[currentIndex].split <span class="hljs-string">'/'</span>
			<span class="hljs-keyword">for</span> currentComponentIndex <span class="hljs-keyword">in</span> [<span class="hljs-number">0.</span>..components.length]
				<span class="hljs-keyword">continue</span> <span class="hljs-keyword">if</span> currentComponentIndex &gt; <span class="hljs-number">0</span>
				index = parseInt components[currentComponentIndex]
				<span class="hljs-keyword">if</span> index &gt; <span class="hljs-number">0</span>
					parsedIndex = index - <span class="hljs-number">1</span>
				<span class="hljs-keyword">else</span>
					parsedIndex = <span class="hljs-property">@parsed</span>[currentComponentIndex].length - index
				<span class="hljs-property">@out</span>[currentComponentIndex].push.apply <span class="hljs-property">@out</span>[currentComponentIndex], <span class="hljs-property">@parsed</span>[currentComponentIndex][parsedIndex]
			<span class="hljs-property">@indices</span>.push <span class="hljs-property">@indices</span>.length
		<span class="hljs-keyword">return</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <!-- Sorry for the non breaking spaces I have added to the method headers. They are there as the markdown parser don't
like one char headers if I'm using the hyphen H2 markdown. But I still want it instead of the hash version as it's a
lot better for the readability. -->

            </div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
